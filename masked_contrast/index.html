<!DOCTYPE html>
<html lang="en-GB">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Mike Capp">
    <meta name="description"
        content="PoC for helping accessibility checkers consider CSS's text-shadow when assessing contrast">
    <title>masked contrast PoC - webtoys</title>
    <link rel="icon" href="data:,">
    <style>
        html, body, main, canvas, p, fieldset, pre { margin: 0; padding: 0; line-height: normal; }
        main { position: relative; max-width: 50em; margin: 2em auto; font: 10pt sans-serif; background-color: white; }
        main > * { width: 500px; border: 1px solid black; box-sizing: border-box; }
        canvas#canvas, div#dom-div { height: 100px; position: relative; overflow: clip; }
        #dom-text { position: absolute; }

        fieldset { margin-top: 8px; padding: 8px; }
        fieldset label { display: block; padding: 4px 0; }
        fieldset label > * { display: inline-block; }
        fieldset label span { width: 150px; }
        fieldset select { width: 320px; }
    </style>
</head>

<body>
    <main>
        <noscript>This webtoy uses JavaScript and won't work without it</noscript>
        <canvas id="canvas" aria-label="text drawn on a non-contrasting background">
            Your browser does not support the &lt;canvas> element
        </canvas>
        <div id="dom-div">
            <p id="dom-text"></p>
        </div>
        <fieldset>
            <legend>Demo configuration</legend>
            <label>
                <span>Draw using</span>
                <select id="renderer">
                    <option value="d">DOM text on a &lt;div> with a background-image</option>
                    <option value="c">Canvas calls for both text and background</option>
                </select>
            </label>
            <label>
                <span>Contrast enhancement</span>
                <select id="enhance">
                    <option value="0">None</option>
                    <option value="1">Weak text-shadow</option>
                    <option value="2">Medium text-shadow</option>
                    <option value="4" selected>Strong text-shadow</option>
                </select>
            </label>
            <label>
                <span>Colour scheme</span>
                <select id="scheme">
                    <option value="e">Enhanced (white fill, pale bg, black shadow)</option>
                    <option value="g">Garish</option>
                    <option value="x">Stupid (white fill, bg, shadow)</option>
                </select>
            </label>
            <label>
                <span>Shadow offset</span>
                <select id="offset">
                    <option value="n">None</option>
                    <option value="t">Tasteful (2px)</option>
                    <option value="x">Excessive (5px)</option>
                    <option value="z">Silly (50px)</option>
                </select>
            </label>
            <label>
                <span>Shadow blur radius</span>
                <select id="radius">
                    <option value="n">None</option>
                    <option value="t">Tiny</option>
                    <option value="s">Small</option>
                    <option value="r" selected>Reasonable</option>
                    <option value="x">Extreme</option>
                </select>
            </label>
        </fieldset>
        <fieldset id="analytic">
            <legend>Analytic contrast</legend>
            <pre></pre>
        </fieldset>
        <fieldset id="image-based">
            <legend>Image-based contrast</legend>
            <button type="button" id="show-box">Show Box</button>
        </fieldset>
    </main>
    <script>
        function $(qs) { return document.querySelector(qs); }
        function $$(qs) { return document.querySelectorAll(qs); }

        const elements = {
            canvas: $("canvas"),
            domDiv: $("#dom-div"),
            domText: $("#dom-text"),
            analytic: $("#analytic"),
            imageBased: $("#image-based"),
        };

        const ctx = $("#canvas").getContext("2d");
        const text = "Hello, world!";
        const defaultHash = Array.from($$("select")).map(e => e.value).join("");
        const schemes = { // don't use named colours here, it messes with the analytic approach
            e: { fg: "#eee", bg: "#def", ss: "#000" },
            g: { fg: "#fd8", bg: "#8df", ss: "#dfd" },
            x: { fg: "#fff", bg: "#fff", ss: "#fff" },
        };
        const offsets = { n: 0, t: 2, x: 5, z: 50 };
        const radii = {
            n: { d: 0 , c: 0 },
            t: { d: 1, c: 1 },
            s: { d: 2, c: 2 },
            r: { d: 7, c: 6 },
            x: { d: 35, c: 38 },
        };
        const pos = { x: 200, y: 20 };
        const fontSize = 48;

        // Called to repaint the world whenever anything changes; we're not getting incrementally fancy here
        //
        function update(e, optOverlay) {

            const useCanvas = $("#renderer").value === "c";
            elements.canvas.style.display = useCanvas ? "block" : "none";
            elements.domDiv.style.display = useCanvas ? "none" : "block";
            elements.analytic.style.display = useCanvas ? "none" : "block";
            elements.imageBased.style.display = useCanvas ? "block" : "none";
            const enhance = Number.parseInt($("#enhance").value);
            const scheme = schemes[$("#scheme").value];
            const offset = offsets[$("#offset").value];
            const radius = radii[$("#radius").value];
            
            // Redraw ALL the things!
            //
            if (useCanvas) {
                ctx.fillStyle = scheme.bg;
                ctx.fillRect(0, 0, 500, 100);
                ctx.font = fontSize + "px sans-serif";
                ctx.textBaseline = "top";
                if (enhance > 0 && (offset || radius.c)) { // fringing hack shouldn't force shadows by itself
                    const MULTIPASS_FRINGING_HACK = 1000;
                    ctx.shadowColor = scheme.ss;
                    ctx.shadowBlur = radius.c;
                    ctx.shadowOffsetX = ctx.shadowOffsetY = offset;
                    ctx.shadowOffsetY += MULTIPASS_FRINGING_HACK;
                    for (let i = 0; i < enhance; ++i) {
                        ctx.fillText(text, pos.x, pos.y + 5 - MULTIPASS_FRINGING_HACK);
                    }
                    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
                }
                ctx.fillStyle = scheme.fg;
                ctx.fillText(text, pos.x, pos.y + 5);

                calculateImageBasedContrast(optOverlay);
            } else {

                elements.domDiv.style.backgroundColor = scheme.bg;
                elements.domText.style.font = fontSize + "px sans-serif";
                elements.domText.style.color = scheme.fg;
                elements.domText.style.textShadow = (enhance > 0) 
                    ? Array(enhance).fill(`${offset}px ${offset}px ${radius.d}px ${scheme.ss}`).join(", ")
                    : "none";
                elements.domText.style.left = pos.x + "px";
                elements.domText.style.top = pos.y + "px";
                elements.domText.textContent = text;

                calculateAnalyticContrast();
            }

            // Update the location hash to reflect current settings, allowing bookmarking and nondestructive reload
            //
            history.replaceState(undefined, undefined, "#" + Array.from($$("select")).map(e => e.value).join(""));

            $("#offset").disabled = (enhance == 0);
            $("#radius").disabled = (enhance == 0);
        }

        function calculateAnalyticContrast() {
            const lines = [];

            const bg = $("#dom-div").style.backgroundColor;
            const bgLum = luminance(numbers(bg));
            lines.push(`background colour: ${bg}\n  luminance: ${bgLum}`);

            const style = $("#dom-text").style;
            const fg = style.color;
            const fgLum = luminance(numbers(fg));
            const baseContrast = contrast(bgLum, fgLum);
            lines.push(`text colour: ${fg}\n  luminance: ${fgLum}`);
            lines.push(`text/background contrast: ${baseContrast}`)
            
            if (style.textShadow !== "none") {
                const shadows = [...style.textShadow.match(/rgb.*?px(?=,|$)/g)];
                const stack = shadows.length;
                const shadow = shadows[0]; // assuming homogenous stack for simplicity
                const [r, g, b, x, y, blur] = numbers(shadow);
                const shadowLum = luminance([r, g, b]);

                // The calcs above are uncontroversial; from here on down we start to get opinionated.

                // Estimate width of each stroke of a glyph (usually but not necessarily vertical), e.g. the 
                // width of an 'L' vertical or the height of an 'H' crossbar. This is not the same as the 
                // "stroke" used in canvas or SVG rendering, which is an outline width. Divisor is a pure
                // guess based on eyeballing some examples. We use the stemWidth to scale offset and blur.
                //
                const stemWidth = numbers(style.fontSize)[0] / 10;

                // With no blur, we'll get the best contrast with an offset of at least half the stemWidth. 
                // Offsets >= stemWidth will become detached from their glyphs and should be punished; even
                // if the shadow is more readable than the original, there's no guarantee it's even onscreen.
                // A zero offset is as useful as a chocolate teapot and should be *severely* punished.
                //
                // We might want to give a higher weighting to balanced offsets here, since e.g. a y-only
                // offset shadow isn't going to do much for the readability of a lowercase sans-serif 'l'.
                // Not doing that for now though; I suspect single-axis offsets aren't too common.
                //
                const offset = Math.max(Math.abs(x), Math.abs(y));
                const offsetExposure = opinionatedExposure(stemWidth, offset, 0.6, 4);

                // With no offset, we'll get the best contrast halo with a blur of ~(1.4 * stemWidth). 
                // This maximizes the number of glyph-covered pixels contributing to the Gaussian kernel, 
                // without diluting too much beyond that. You might think (1 + stemWidth) would be better, but
                // remember the kernel is going to be sampling at offsets angled to the adjacent stem too.
                //
                const blurExposure = opinionatedExposure(stemWidth, blur, 1.4, 1.5);

                // Combining blur and offset generally gives the best results, but either by itself can help.
                // Blur is weighted heavier since offset by itself can only provide contrast on one glyph edge.
                //
                // We might want to make the impact of offset inversely proportional to blur radius, up to a point.
                // Offset is essential with zero blur and largely irrelevant with high blur. In practice, though,
                // the lack of alpha dilution with zero blur kind of does this, and adding explicit weightings
                // on top of that seemed to overcorrect.
                //
                const combinedExposure = (0.2 * offsetExposure) + (0.7 * blurExposure) + (0.1 * offsetExposure * blurExposure);

                // Roughly estimate how much blurring has reduced peak alpha of our shadows. We'll often need to
                // stack shadows to counteract this dilution.
                //
                const dilutedAlpha = fittedAlpha(blur);

                // Luminance of background with all stacked shadows composited onto it
                //
                const bgShineThrough = (1 - dilutedAlpha) ** stack;
                const shadowedBgLum = shadowLum * (1 - bgShineThrough) + bgLum * bgShineThrough;

                // Calculate the ideal foreground/shadow contrast, and scale that by our exposure metric to produce
                // an overall impact estimate for our shadows.
                //
                const idealContrast = contrast(fgLum, shadowedBgLum);
                const finalContrast = idealContrast * combinedExposure + baseContrast * (1 - combinedExposure);

                lines.push(`shadow: ${shadow}\n  stack: ${stack}\n  base luminance: ${shadowLum}`);
                lines.push(`  dilutedAlpha (per shadow): ${dilutedAlpha}`);
                lines.push(`  exposure:\n    offset: ${offsetExposure}\n    blur: ${blurExposure}\n    combined: ${combinedExposure}`);
                lines.push(`  bgShineThrough: ${bgShineThrough}`);
                lines.push(`  shadowed background luminance: ${shadowedBgLum}`);
                lines.push(`  ideal shadow contrast: ${idealContrast}`);
                lines.push(`<b>final contrast: ${finalContrast}</b>`);
            }

            $("#analytic pre").innerHTML = lines.join("\n");

            function numbers(s) {
                return s.match(/[0-9]+/g).map(Number);
            }

            function luminance(rgb) { // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance
                const [r, g, b] = rgb.map(linearize);
                return (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
                function linearize(c) {
                    c /= 255;
                    return (c <= 0.04045) 
                        ? (c / 12.92) 
                        : Math.pow(((c + 0.055) / 1.055), 2.4);
                }
            }

            function contrast(lum1, lum2) { // https://www.w3.org/TR/WCAG21/#dfn-contrast-ratio
                const lighter = Math.max(lum1, lum2);
                const darker = Math.min(lum1, lum2);
                return (lighter + 0.05) / (darker + 0.05); // avoid possible divide by zero
            }

            function opinionatedExposure(stemWidth, raw, ideal, excessExponent) {
                let norm = raw / stemWidth;
                let exposure = norm / ideal;
                if (exposure > 1) exposure /= (exposure ** excessExponent);
                return exposure;
            }

            function fittedAlpha(blur) { // curve by ChatGPT from empirical tests at 48px font
                return 1 / (1 + 9.035 * (blur / fontSize) ** 2);
            }
        }

        function calculateImageBasedContrast(optOverlay) {
            const bcrDiv = elements.domDiv.getBoundingClientRect();
            const bcrText = elements.domText.getBoundingClientRect();
            const metrics = ctx.measureText(text);
            const [x, y, w, h] = [pos.x, pos.y, metrics.width, metrics.actualBoundingBoxDescent - metrics.actualBoundingBoxAscent];
            const pixels = ctx.getImageData(x, y, w, h);

            if (optOverlay === "box") {
                ctx.strokeStyle = "fuchsia";
                ctx.strokeRect(x, y, w, h);
            }
        }

        function populateFromHash() {
            var h = location.hash.replace("#", "").substr(0, defaultHash.length);
            h += defaultHash.substr(h.length);

            Array.from($$("select")).forEach(validatedSet);
            update();

            function validatedSet(el, i) {
                const v = h[i];
                const legit = Array.from(el.options).map(o => o.value);
                if (legit.includes(v)) {
                    el.value = v;
                } else {
                    let reset = defaultHash[i];
                    alert(`'${v}' is not a valid value for '${el.id}'.\nAllowed values are [${legit}].\nResetting to default '${reset}'.`);
                    el.value = reset;
                }
            }
        }

        // One-time initialization
        //
        (function init() {

            // Adjust canvas for high-DPI displays (untested, I don't have one)
            //
            const scale = window.devicePixelRatio;
            canvas.width = canvas.clientWidth * scale;
            canvas.height = canvas.clientHeight * scale;
            ctx.scale(scale, scale);

            window.addEventListener("hashchange", populateFromHash);
            document.querySelectorAll("select").forEach(el => el.addEventListener("change", update));
            $("button#show-box").addEventListener("mousedown", e => update(e, "box"));
            $("button#show-box").addEventListener("mouseup", update);
            $("button#show-box").addEventListener("mouseout", update);

            populateFromHash();
        })();
    </script>
</body>

</html>