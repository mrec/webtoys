<!DOCTYPE html>
<html lang="en-GB">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Mike Capp">
    <meta name="description"
        content="PoC for helping accessibility checkers consider CSS's text-shadow when assessing contrast">
    <title>masked contrast PoC - webtoys</title>
    <link rel="icon" href="data:,">
    <style>
        html, body, main, canvas, p, fieldset, pre { margin: 0; padding: 0; line-height: normal; }
        main { max-width: 50em; margin: 2em auto; font: 10pt sans-serif; background-color: white; }
        #gfx, fieldset { width: 502px; border: 1px solid black; box-sizing: border-box; }
        #gfx { position: relative; }
        canvas#canvas, div#dom-div { width: 500px; height: 100px; position: relative; overflow: clip; }
#mask-canvas { position: absolute; display: block; }
        #dom-text { position: absolute; }

        fieldset { margin-top: 8px; padding: 8px; }
        fieldset label { display: block; padding: 4px 0; }
        fieldset label > * { display: inline-block; }
        fieldset label span { width: 150px; }
        fieldset select { width: 320px; }

        span.swatch { display: inline-block; border: 1px solid black; width: 2em; margin-right: 1em; }
        fieldset#image-based div { margin: 8px 0; }
    </style>
</head>

<body>
    <main>
        <noscript>This webtoy uses JavaScript and won't work without it</noscript>
        <div id="gfx">
            <canvas id="canvas" aria-label="text drawn on a non-contrasting background">
                Your browser does not support the &lt;canvas> element
            </canvas>
            <canvas id="mask-canvas"></canvas>
            <div id="dom-div">
                <p id="dom-text"></p>
            </div>
        </div>
        <fieldset>
            <legend>Demo configuration</legend>
            <label>
                <span>Draw using</span>
                <select id="renderer">
                    <option value="d">DOM text on a &lt;div> with a background-image</option>
                    <option value="c">Canvas calls for both text and background</option>
                </select>
            </label>
            <label>
                <span>Contrast enhancement</span>
                <select id="enhance">
                    <option value="0">None</option>
                    <option value="1">Weak text-shadow</option>
                    <option value="2">Medium text-shadow</option>
                    <option value="4" selected>Strong text-shadow</option>
                </select>
            </label>
            <label>
                <span>Colour scheme</span>
                <select id="scheme">
                    <option value="e">Enhanced (white fill, pale bg, black shadow)</option>
                    <option value="g">Garish</option>
                    <option value="x">Stupid (white fill, bg, shadow)</option>
                </select>
            </label>
            <label>
                <span>Shadow offset</span>
                <select id="offset">
                    <option value="n">None</option>
                    <option value="t">Tasteful (2px)</option>
                    <option value="x">Excessive (5px)</option>
                    <option value="z">Silly (50px)</option>
                </select>
            </label>
            <label>
                <span>Shadow blur radius</span>
                <select id="radius">
                    <option value="n">None</option>
                    <option value="t">Tiny</option>
                    <option value="s">Small</option>
                    <option value="r" selected>Reasonable</option>
                    <option value="x">Extreme</option>
                </select>
            </label>
        </fieldset>
        <fieldset id="analytic">
            <legend>Analytic contrast</legend>
            <pre></pre>
        </fieldset>
        <fieldset id="image-based">
            <legend>Image-based contrast</legend>
            <button type="button" id="hide-text" title="Show the background without text, as the contrast checker will see it">Hide Text</button>
            <button type="button" id="show-box" title="Show the pixel box we'll consider as background">Show Box</button>
            <button type="button" id="show-mask" title="Show the dilation mask">Show Mask</button>
            <div><span id="best-swatch-box" class="swatch">&nbsp;</span>Best contrast (box): <span id="best-contrast-box"></span></div>
            <div><span id="worst-swatch-box" class="swatch">&nbsp;</span>Worst contrast (box): <span id="worst-contrast-box"></span></div>
        </fieldset>
    </main>
    <script>
        function $(qs) { return document.querySelector(qs); }
        function $$(qs) { return document.querySelectorAll(qs); }

        const elements = {
            canvas: $("canvas"),
            domDiv: $("#dom-div"),
            domText: $("#dom-text"),
            analytic: $("#analytic"),
            imageBased: $("#image-based"),
        };

        const ctx = $("#canvas").getContext("2d");
        const text = "Hello, world!";
        const defaultHash = Array.from($$("select")).map(e => e.value).join("");
        const schemes = { // don't use named colours here, it complicates parsing
            e: { fg: "#eee", bg: "#def", ss: "#000" },
            g: { fg: "#fd8", bg: "#8df", ss: "#dfd" },
            x: { fg: "#fff", bg: "#fff", ss: "#fff" },
        };
        const offsets = { n: 0, t: 2, x: 5, z: 50 };
        const radii = {
            n: { d: 0 , c: 0 },
            t: { d: 1, c: 1 },
            s: { d: 2, c: 2 },
            r: { d: 7, c: 6 },
            x: { d: 35, c: 38 },
        };
        const pos = { x: 200, y: 20 };
        const fontSize = 48;

        /** Called to repaint the world whenever anything changes; we're not getting incrementally fancy here */
        function update(e, opt) {

            const useCanvas = $("#renderer").value === "c";
            elements.canvas.style.display = useCanvas ? "block" : "none";
            elements.domDiv.style.display = useCanvas ? "none" : "block";
            elements.analytic.style.display = useCanvas ? "none" : "block";
            elements.imageBased.style.display = useCanvas ? "block" : "none";
            const enhance = Number.parseInt($("#enhance").value);
            const scheme = schemes[$("#scheme").value];
            const offset = offsets[$("#offset").value];
            const radius = radii[$("#radius").value];
            
            // Redraw ALL the things!
            //
            if (useCanvas) {
                ctx.fillStyle = scheme.bg;
                ctx.fillRect(0, 0, 500, 100);
                ctx.font = fontSize + "px sans-serif";
                ctx.textBaseline = "top";
                if (enhance > 0 && (offset || radius.c)) { // fringing hack shouldn't force shadows by itself
                    const MULTIPASS_FRINGING_HACK = 1000;
                    ctx.shadowColor = scheme.ss;
                    ctx.shadowBlur = radius.c;
                    ctx.shadowOffsetX = ctx.shadowOffsetY = offset;
                    ctx.shadowOffsetY += MULTIPASS_FRINGING_HACK;
                    for (let i = 0; i < enhance; ++i) {
                        ctx.fillText(text, pos.x, pos.y + 5 - MULTIPASS_FRINGING_HACK);
                    }
                    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
                }

                const bcrDiv = elements.domDiv.getBoundingClientRect();
                const bcrText = elements.domText.getBoundingClientRect();
                const metrics = ctx.measureText(text);
                const [x, y, w, h] = [pos.x, pos.y, metrics.width, metrics.actualBoundingBoxDescent - metrics.actualBoundingBoxAscent];
                const pixels = ctx.getImageData(x, y, w, h);

                const maskCanvas = $("#mask-canvas"); //new OffscreenCanvas(w, h);
                maskCanvas.width = w;
                maskCanvas.height = h;
                maskCanvas.style.left = x + "px";
                maskCanvas.style.top = y + "px";
                const mctx = maskCanvas.getContext("2d");
                const svg = `
<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">
  <defs>
    <filter id="dilate" x="-10%" y="-10%" width="120%" height="120%">
      <feComponentTransfer in="SourceAlpha" result="alpha">
        <feFuncA type="discrete" tableValues="0 1"/>
      </feComponentTransfer>
      <feMorphology in="alpha" operator="dilate" radius="2" result="dilated"/>
      <feComposite in="dilated" in2="alpha" operator="out" result="border"/>
      <feFlood flood-color="fuchsia" result="flood"/>
      <feComposite in="flood" in2="border" operator="in"/>
    </filter>
  </defs>
  <text x="0" y="10"
        dominant-baseline="hanging"
        text-anchor="start"
        font-family="sans-serif"
        font-size="${fontSize}px"
        filter="url(#dilate)"
        fill="black">${text}</text>
</svg>`;
const svgBlob = new Blob([svg], { type: "image/svg+xml" });
const url = URL.createObjectURL(svgBlob);
const img = new Image();
img.onload = () => { // TODO: need to block on this before drawing mask canvas onto main
    mctx.drawImage(img, 0, 0);
    URL.revokeObjectURL(url); // Clean up
};
img.src = url;
                
                if (opt === "box") {
                    ctx.strokeStyle = "fuchsia";
                    ctx.strokeRect(x, y, w, h);
                } else if (opt === "mask") {
                    ctx.drawImage(maskCanvas, x, y);
                }
                
                if (opt !== "hide") {
                    ctx.fillStyle = scheme.fg;
                    ctx.fillText(text, pos.x, pos.y + 5);
                }

                calculateImageBasedContrast(scheme.fg, pixels.data);
            } else {

                elements.domDiv.style.backgroundColor = scheme.bg;
                elements.domText.style.font = fontSize + "px sans-serif";
                elements.domText.style.color = scheme.fg;
                elements.domText.style.textShadow = (enhance > 0) 
                    ? Array(enhance).fill(`${offset}px ${offset}px ${radius.d}px ${scheme.ss}`).join(", ")
                    : "none";
                elements.domText.style.left = pos.x + "px";
                elements.domText.style.top = pos.y + "px";
                elements.domText.textContent = text;

                calculateAnalyticContrast();
            }

            // Update the location hash to reflect current settings, allowing bookmarking and nondestructive reload
            //
            history.replaceState(undefined, undefined, "#" + Array.from($$("select")).map(e => e.value).join(""));

            $("#offset").disabled = (enhance == 0);
            $("#radius").disabled = (enhance == 0);
        }

        function calculateAnalyticContrast() {
            const lines = [];

            const bg = $("#dom-div").style.backgroundColor;
            const bgLum = luminance(numbers(bg));
            lines.push(`background colour: ${bg}\n  luminance: ${bgLum}`);

            const style = $("#dom-text").style;
            const fg = style.color;
            const fgLum = luminance(numbers(fg));
            const baseContrast = contrast(bgLum, fgLum);
            lines.push(`text colour: ${fg}\n  luminance: ${fgLum}`);
            lines.push(`text/background contrast: ${baseContrast}`)
            
            if (style.textShadow !== "none") {
                const shadows = [...style.textShadow.match(/rgb.*?px(?=,|$)/g)];
                const stack = shadows.length;
                const shadow = shadows[0]; // assuming homogenous stack for simplicity
                const [r, g, b, x, y, blur] = numbers(shadow);
                const shadowLum = luminance([r, g, b]);

                // The calcs above are uncontroversial; from here on down we start to get opinionated.

                // Estimate width of each stroke of a glyph (usually but not necessarily vertical), e.g. the 
                // width of an 'L' vertical or the height of an 'H' crossbar. This is not the same as the 
                // "stroke" used in canvas or SVG rendering, which is an outline width. Divisor is a pure
                // guess based on eyeballing some examples. We use the stemWidth to scale offset and blur.
                //
                const stemWidth = numbers(style.fontSize)[0] / 10;

                // With no blur, we'll get the best contrast with an offset of at least half the stemWidth. 
                // Offsets >= stemWidth will become detached from their glyphs and should be punished; even
                // if the shadow is more readable than the original, there's no guarantee it's even onscreen.
                // A zero offset is as useful as a chocolate teapot and should be *severely* punished.
                //
                // We might want to give a higher weighting to balanced offsets here, since e.g. a y-only
                // offset shadow isn't going to do much for the readability of a lowercase sans-serif 'l'.
                // Not doing that for now though; I suspect single-axis offsets aren't too common.
                //
                const offset = Math.max(Math.abs(x), Math.abs(y));
                const offsetExposure = opinionatedExposure(stemWidth, offset, 0.6, 4);

                // With no offset, we'll get the best contrast halo with a blur of ~(1.4 * stemWidth). 
                // This maximizes the number of glyph-covered pixels contributing to the Gaussian kernel, 
                // without diluting too much beyond that. You might think (1 + stemWidth) would be better, but
                // remember the kernel is going to be sampling at offsets angled to the adjacent stem too.
                //
                const blurExposure = opinionatedExposure(stemWidth, blur, 1.4, 1.5);

                // Combining blur and offset generally gives the best results, but either by itself can help.
                // Blur is weighted heavier since offset by itself can only provide contrast on one glyph edge.
                //
                // We might want to make the impact of offset inversely proportional to blur radius, up to a point.
                // Offset is essential with zero blur and largely irrelevant with high blur. In practice, though,
                // the lack of alpha dilution with zero blur kind of does this, and adding explicit weightings
                // on top of that seemed to overcorrect.
                //
                const combinedExposure = (0.2 * offsetExposure) + (0.7 * blurExposure) + (0.1 * offsetExposure * blurExposure);

                // Roughly estimate how much blurring has reduced peak alpha of our shadows. We'll often need to
                // stack shadows to counteract this dilution.
                //
                const dilutedAlpha = fittedAlpha(blur);

                // Luminance of background with all stacked shadows composited onto it
                //
                const bgShineThrough = (1 - dilutedAlpha) ** stack;
                const shadowedBgLum = shadowLum * (1 - bgShineThrough) + bgLum * bgShineThrough;

                // Calculate the ideal foreground/shadow contrast, and scale that by our exposure metric to produce
                // an overall impact estimate for our shadows.
                //
                const idealContrast = contrast(fgLum, shadowedBgLum);
                const finalContrast = idealContrast * combinedExposure + baseContrast * (1 - combinedExposure);

                lines.push(`shadow: ${shadow}\n  stack: ${stack}\n  base luminance: ${shadowLum}`);
                lines.push(`  dilutedAlpha (per shadow): ${dilutedAlpha}`);
                lines.push(`  exposure:\n    offset: ${offsetExposure}\n    blur: ${blurExposure}\n    combined: ${combinedExposure}`);
                lines.push(`  bgShineThrough: ${bgShineThrough}`);
                lines.push(`  shadowed background luminance: ${shadowedBgLum}`);
                lines.push(`  ideal shadow contrast: ${idealContrast}`);
                lines.push(`<b>final contrast: ${finalContrast}</b>`);
            }

            $("#analytic pre").innerHTML = lines.join("\n");

            function opinionatedExposure(stemWidth, raw, ideal, excessExponent) {
                let norm = raw / stemWidth;
                let exposure = norm / ideal;
                if (exposure > 1) exposure /= (exposure ** excessExponent);
                return exposure;
            }

            function fittedAlpha(blur) { // curve by ChatGPT from empirical tests at 48px font
                return 1 / (1 + 9.035 * (blur / fontSize) ** 2);
            }
        }

        function calculateImageBasedContrast(fgColor, pixelData) {
            const fgLum = luminance(hexColor(fgColor));
            let cBest = 1, cWorst = 21;
            let rgbBest = [], rgbWorst = [];
            for (let i = 0; i < pixelData.length; i += 4) {
                let r = pixelData[i];
                let g = pixelData[i + 1];
                let b = pixelData[i + 2];

                let bgLum = luminance([r, g, b]);
                let c = contrast(fgLum, bgLum);
                if (c > cBest) {
                    cBest = c;
                    rgbBest = [r, g, b];
                }
                if (c < cWorst) {
                    cWorst = c;
                    rgbWorst = [r, g, b];
                }
            }
            $("#best-swatch-box").style.backgroundColor = `rgb(${rgbBest[0]}, ${rgbBest[1]}, ${rgbBest[1]})`;
            $("#worst-swatch-box").style.backgroundColor = `rgb(${rgbWorst[0]}, ${rgbWorst[1]}, ${rgbWorst[1]})`;
            $("#best-contrast-box").textContent = cBest.toFixed(3);
            $("#worst-contrast-box").textContent = cWorst.toFixed(3);
        }

        /** Extracts all integer values from `s` as an array */
        function numbers(s) {
            return s.match(/[0-9]+/g).map(Number);
        }

        /** Parses `hex` as an `#nnn` hex value, returning [r, g, b] */
        function hexColor(hex) {
            return [parseHexDigit(hex[1]), parseHexDigit(hex[2]), parseHexDigit(hex[3])];
            function parseHexDigit(d) {
                let n = parseInt(d, 16);
                return (n << 4) + n;
            }
        }

        /** Luminance of an `[r, g, b]` uint8-valued array, in the range 0..=1 */
        function luminance(rgb) { // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance
            const [r, g, b] = rgb.map(linearize);
            return (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
            function linearize(c) {
                c /= 255;
                return (c <= 0.04045) 
                    ? (c / 12.92) 
                    : Math.pow(((c + 0.055) / 1.055), 2.4);
            }
        }

        /** Contrast between two luminance values, in the range 1 (worst) to 21 (best) */
        function contrast(lum1, lum2) { // https://www.w3.org/TR/WCAG21/#dfn-contrast-ratio
            const lighter = Math.max(lum1, lum2);
            const darker = Math.min(lum1, lum2);
            return (lighter + 0.05) / (darker + 0.05); // avoid possible divide by zero
        }

        function populateFromHash() {
            var h = location.hash.replace("#", "").substr(0, defaultHash.length);
            h += defaultHash.substr(h.length);

            Array.from($$("select")).forEach(validatedSet);
            update();

            function validatedSet(el, i) {
                const v = h[i];
                const legit = Array.from(el.options).map(o => o.value);
                if (legit.includes(v)) {
                    el.value = v;
                } else {
                    let reset = defaultHash[i];
                    alert(`'${v}' is not a valid value for '${el.id}'.\nAllowed values are [${legit}].\nResetting to default '${reset}'.`);
                    el.value = reset;
                }
            }
        }

        /** One-time initialization */
        (function init() {

            // Adjust canvas for high-DPI displays (untested, I don't have one)
            //
            const scale = window.devicePixelRatio;
            canvas.width = canvas.clientWidth * scale;
            canvas.height = canvas.clientHeight * scale;
            ctx.scale(scale, scale);

            window.addEventListener("hashchange", populateFromHash);
            document.querySelectorAll("select").forEach(el => el.addEventListener("change", update));
            setUpButton($("button#hide-text"), "hide");
            setUpButton($("button#show-box"), "box");
            setUpButton($("button#show-mask"), "mask");

            populateFromHash();

            function setUpButton(el, opt) {
                el.addEventListener("mousedown", e => update(e, opt));
                el.addEventListener("mouseup", update);
                el.addEventListener("mouseout", update);
            }
        })();
    </script>
</body>

</html>