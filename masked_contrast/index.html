<!DOCTYPE html>
<html lang="en-GB">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Mike Capp">
    <meta name="description" content="PoC for helping accessibility checkers consider CSS's text-shadow when assessing contrast">
    <title>masked contrast PoC - webtoys</title>
    <link rel="icon" href="data:,">
    <link rel="license" href="https://opensource.org/licenses/MIT">
    <link rel="license" href="https://www.apache.org/licenses/LICENSE-2.0">
    <style>
        html, body, main, canvas, p, fieldset, pre { margin: 0; padding: 0; }
        main { width: 302px; margin: 2em auto; font: 10pt sans-serif; background-color: white; }
        #gfx, fieldset { width: 302px; border: 1px solid black; box-sizing: border-box; }
        #gfx { position: relative; }
        #canvas, #dom-div { width: 300px; height: 100px; position: relative; overflow: clip; }
        #dom-text { position: absolute; line-height: 1; transform: translateY(-0.92em) /* approx baseline offset from top */; }

        fieldset { margin-top: 8px; padding: 8px; }
        fieldset label { display: block; padding: 4px 0; }
        fieldset label > * { display: inline-block; }
        fieldset label span { width: 110px; }
        fieldset select { width: 160px; }
        button { width: 68px; }

        fieldset#image-based pre { margin-top: 1em; }
        fieldset#image-based span { display: inline-block; width: 3em; }
    </style>
</head>

<body>
    <main>
        <noscript>This webtoy uses JavaScript and won't work without it</noscript>
        <div id="gfx">
            <canvas id="canvas" width="300" height="100" aria-label="text drawn on a non-contrasting background">
                Your browser does not support the &lt;canvas> element
            </canvas>
            <div id="dom-div">
                <p id="dom-text"></p>
            </div>
        </div>
        <fieldset>
            <legend>Demo configuration</legend>
            <label>
                <span>Draw method</span>
                <select id="renderer" disabled>
                    <option value="d">DOM</option>
                    <option value="c">Canvas</option>
                </select>
            </label>
            <label>
                <span>Shadow strength</span>
                <select id="enhance" disabled>
                    <option value="0">None</option>
                    <option value="1">Weak (x1)</option>
                    <option value="2">Medium (x2)</option>
                    <option value="4" selected>Strong (x4)</option>
                </select>
            </label>
            <label>
                <span>Colour scheme</span>
                <select id="scheme" disabled>
                    <option value="v">Vanilla</option>
                    <option value="e" selected>Needs enhancing</option>
                    <option value="g">Garish</option>
                    <option value="x">Stupid (all-white)</option>
                </select>
            </label>
            <label>
                <span>Shadow offset</span>
                <select id="offset" disabled>
                    <option value="n">None</option>
                    <option value="t">Tasteful (2px)</option>
                    <option value="x">Excessive (5px)</option>
                    <option value="z">Silly (50px)</option>
                </select>
            </label>
            <label>
                <span>Blur radius</span>
                <select id="radius" disabled>
                    <option value="n">None</option>
                    <option value="t">Tiny</option>
                    <option value="s">Small</option>
                    <option value="r" selected>Reasonable</option>
                    <option value="o">Excessive</option>
                    <option value="x">Extreme</option>
                </select>
            </label>
            <label>
                <span>Bg image</span>
                <select id="bgimage" disabled>
                    <option value="n" selected>None</option>
                    <option value="f">Fine checkerboard</option>
                    <option value="c">Coarse checkerboard</option>
                </select>
            </label>
        </fieldset>
        <fieldset id="analytic">
            <legend>Analytic contrast (DOM)</legend>
            <pre></pre>
        </fieldset>
        <fieldset id="image-based">
            <legend>Image-based contrast (Canvas)</legend>
            <button type="button" disabled id="hide-text" title="Show the background without text, as the contrast checker will see it">Hide</button>
            <button type="button" disabled id="show-box" title="Show the outline of the pixel box we'll consider as background">Box</button>
            <button type="button" disabled id="show-mask" title="Show the dilation outline mask">Mask</button>
            <button type="button" disabled id="show-heat" title="Show mask contrast heatmap">Heat</button>
            <pre></pre>
        </fieldset>
    </main>
    <script>
        function $(qs) { return document.querySelector(qs); }
        function $$(qs) { return document.querySelectorAll(qs); }

        const elements = {
            canvas: $("canvas"),
            domDiv: $("#dom-div"),
            domText: $("#dom-text"),
            analytic: $("#analytic"),
            imageBased: $("#image-based"),
        };

        const text = "Hello, world!";
        const pos = { x: 24, y: 64 };
        const fontSize = 48;
        const maskWidth = 2;
        const ctx = $("#canvas").getContext("2d");
        ctx.font = `normal ${fontSize}px/1 sans-serif`;
        ctx.textBaseline = "alphabetic";
        const box = (function() {
            const metrics = window.metrics = ctx.measureText(text);
            return {
                x: Math.round(pos.x - metrics.actualBoundingBoxLeft) - maskWidth - 1,
                y: Math.round(pos.y - metrics.actualBoundingBoxAscent) - maskWidth - 1,
                w: Math.round(metrics.width) + maskWidth * 2 + 2,
                h: Math.round(metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent) + maskWidth * 2 + 2
            };
        })();

        const defaultHash = Array.from($$("select")).map(e => e.value).join("");
        const schemes = { // don't use named colours here, it complicates parsing
            v: { fg: "#000", bg: "#fff", ss: "#000" },
            e: { fg: "#eee", bg: "#def", ss: "#000" },
            g: { fg: "#fd8", bg: "#8df", ss: "#dfd" },
            x: { fg: "#fff", bg: "#fff", ss: "#fff" },
        };
        const offsets = { n: 0, t: 2, x: 5, z: 50 };
        const radii = {
            n: { d: 0 , c: 0 },
            t: { d: 1, c: 1 },
            s: { d: 2, c: 2 },
            r: { d: 7, c: 6 },
            o: { d: 10, c: 9 },
            x: { d: 35, c: 38 },
        };

        const maskCanvas = (function() {
            const c = document.createElement("canvas"); // OffscreenCanvas isn't as well supported
            c.width = 300; 
            c.height = 100;
            return c;
        })();

        var maskBytes; // initialized asynchronously by init(), may be undefined if filter unsupported
        var checkerboardImage;  // ditto
        var heatMap = new ImageData(box.w, box.h);
        
        init();

        /** Called to repaint the world whenever anything changes; we're not getting incrementally fancy here */
        function update(e, opt) {

            const useCanvas = $("#renderer").value === "c";
            elements.canvas.style.display = useCanvas ? "block" : "none";
            elements.domDiv.style.display = useCanvas ? "none" : "block";
            elements.analytic.style.display = useCanvas ? "none" : "block";
            elements.imageBased.style.display = useCanvas ? "block" : "none";
            const enhance = Number.parseInt($("#enhance").value);
            const scheme = schemes[$("#scheme").value];
            const offset = offsets[$("#offset").value];
            const radius = radii[$("#radius").value];
            const bgimage = $("#bgimage").value;
            
            // Redraw ALL the things!
            //
            if (useCanvas) {
                ctx.fillStyle = scheme.bg;
                ctx.fillRect(0, 0, 300, 100);

                if (enhance > 0 && (offset || radius.c)) { // fringing hack shouldn't force shadows by itself
                    const MULTIPASS_FRINGING_HACK = 1000;
                    ctx.shadowColor = ctx.fillStyle = scheme.ss;
                    ctx.shadowBlur = radius.c;
                    ctx.shadowOffsetX = ctx.shadowOffsetY = offset;
                    ctx.shadowOffsetY += MULTIPASS_FRINGING_HACK;
                    for (let i = 0; i < enhance; ++i) {
                        ctx.fillText(text, pos.x, pos.y - MULTIPASS_FRINGING_HACK);
                    }
                    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
                }

                const pixels = ctx.getImageData(box.x, box.y, box.w, box.h); // before any overlays

                if (opt === "box") {
                    ctx.strokeStyle = "fuchsia";
                    ctx.strokeRect(box.x - 0.5, box.y - 0.5, box.w, box.h);
                } else if (opt === "mask") {
                    ctx.drawImage(maskCanvas, 0, 0);
                } else if (opt === "heat") {
                    ctx.fillStyle = "black";
                    ctx.fillRect(0, 0, 300, 100);
                    ctx.putImageData(heatMap, box.x, box.y);
                }
                
                if (opt !== "hide" && opt != "heat") {
                    ctx.fillStyle = scheme.fg;
                    ctx.fillText(text, pos.x, pos.y);
                }

                if (maskBytes && !opt) { // avoid weird stats jitter on overlay updates
                    calculateImageBasedContrast(scheme.fg, pixels.data, heatMap.data);
                }
            } else { // DOM drawing
                let dds = elements.domDiv.style;
                dds.backgroundColor = scheme.bg;
                dds.backgroundImage = (bgimage === "n" ? "none" : `url("${checkerboardImage.src}")`);
                dds.backgroundSize = (bgimage === "c" ? "100px" : "auto");
                dds.imageRendering = "pixelated";

                let dts = elements.domText.style;
                dts.font = fontSize + "px sans-serif";
                dts.color = scheme.fg;
                dts.textShadow = (enhance > 0) 
                    ? Array(enhance).fill(`${offset}px ${offset}px ${radius.d}px ${scheme.ss}`).join(", ")
                    : "none";
                dts.left = pos.x + "px";
                dts.top = pos.y + "px";
                elements.domText.textContent = text;

                if (bgimage === "n") {
                    calculateAnalyticContrast();
                } else {
                    $("#analytic pre").textContent = "Not supported with background-image";
                }
            }

            // Update the location hash to reflect current settings, allowing bookmarking and nondestructive reload
            //
            history.replaceState(undefined, undefined, "#!" + Array.from($$("select")).map(e => e.value).join(""));

            $("#offset").disabled = (enhance == 0);
            $("#radius").disabled = (enhance == 0);
        }

        function calculateAnalyticContrast() {
            const lines = [];

            const bg = $("#dom-div").style.backgroundColor;
            const bgLum = luminance(numbers(bg));
            lines.push(`background colour: ${bg}\n  luminance: ${bgLum.toFixed(2)}`);

            const style = $("#dom-text").style;
            const fg = style.color;
            const fgLum = luminance(numbers(fg));
            const baseContrast = contrast(bgLum, fgLum);
            lines.push(`text colour: ${fg}\n  luminance: ${fgLum.toFixed(2)}`);
            lines.push(`text/background contrast: ${baseContrast.toFixed(2)}`)
            
            if (style.textShadow !== "none") {
                const shadows = [...style.textShadow.match(/rgb.*?px(?=,|$)/g)];
                const stack = shadows.length;
                const shadow = shadows[0]; // assuming homogenous stack for simplicity
                const [r, g, b, x, y, blur] = numbers(shadow);
                const shadowLum = luminance([r, g, b]);

                // The calcs above are uncontroversial; from here on down we start to get opinionated.

                // Estimate width of each stroke of a glyph (usually but not necessarily vertical), e.g. the 
                // width of an 'L' vertical or the height of an 'H' crossbar. This is not the same as the 
                // "stroke" used in canvas or SVG rendering, which is an outline width. Divisor is a pure
                // guess based on eyeballing some examples. We use the stemWidth to scale offset and blur.
                //
                const stemWidth = numbers(style.fontSize)[0] / 10;

                // With no blur, we'll get the best contrast with an offset of at least half the stemWidth. 
                // Offsets >= stemWidth will become detached from their glyphs and should be punished; even
                // if the shadow is more readable than the original, there's no guarantee it's even onscreen.
                // A zero offset is as useful as a chocolate teapot and should be *severely* punished.
                //
                // We might want to give a higher weighting to balanced offsets here, since e.g. a y-only
                // offset shadow isn't going to do much for the readability of a lowercase sans-serif 'l'.
                // Not doing that for now though; I suspect single-axis offsets aren't too common.
                //
                const offset = Math.max(Math.abs(x), Math.abs(y));
                const offsetExposure = opinionatedExposure(stemWidth, offset, 0.6, 4);

                // With no offset, we'll get the best contrast halo with a blur of ~(1.4 * stemWidth). 
                // This maximizes the number of glyph-covered pixels contributing to the Gaussian kernel, 
                // without diluting too much beyond that. You might think (1 + stemWidth) would be better, but
                // remember the kernel is going to be sampling at offsets angled to the adjacent stem too.
                //
                const blurExposure = opinionatedExposure(stemWidth, blur, 1.4, 1.5);

                // Combining blur and offset generally gives the best results, but either by itself can help.
                // Blur is weighted heavier since offset by itself can only provide contrast on one glyph edge.
                //
                // We might want to make the impact of offset inversely proportional to blur radius, up to a point.
                // Offset is essential with zero blur and largely irrelevant with high blur. In practice, though,
                // the lack of alpha dilution with zero blur kind of does this, and adding explicit weightings
                // on top of that seemed to overcorrect.
                //
                const combinedExposure = (0.2 * offsetExposure) + (0.7 * blurExposure) + (0.1 * offsetExposure * blurExposure);

                // Roughly estimate how much blurring has reduced peak alpha of our shadows. We'll often need to
                // stack shadows to counteract this dilution.
                //
                const dilutedAlpha = fittedAlpha(blur);

                // Luminance of background with all stacked shadows composited onto it
                //
                const bgShineThrough = (1 - dilutedAlpha) ** stack;
                const shadowedBgLum = shadowLum * (1 - bgShineThrough) + bgLum * bgShineThrough;

                // Calculate the ideal foreground/shadow contrast, and scale that by our exposure metric to produce
                // an overall impact estimate for our shadows.
                //
                const idealContrast = contrast(fgLum, shadowedBgLum);
                const finalContrast = idealContrast * combinedExposure + baseContrast * (1 - combinedExposure);

                lines.push(
                    `shadow: ${shadow}`,
                    `  stack: x${stack}`,
                    `  base luminance: ${shadowLum.toFixed(2)}`,
                    `  exposure:`,
                    `    offset: ${offsetExposure.toFixed(2)}`,
                    `    blur: ${blurExposure.toFixed(2)}`,
                    `    combined: ${combinedExposure.toFixed(2)}`,
                    `  dilutedAlpha (per shadow): ${dilutedAlpha.toFixed(2)}`,
                    `  dilutedAlpha (cumulative): ${(1 - bgShineThrough).toFixed(2)}`,
                    `  shadowed background luminance: ${shadowedBgLum.toFixed(2)}`,
                    `  ideal shadow contrast: ${idealContrast.toFixed(2)}`,
                    `<b>final exposure-adjusted contrast: ${finalContrast.toFixed(2)}</b>`
                );
            }

            $("#analytic pre").innerHTML = lines.join("\n");

            function opinionatedExposure(stemWidth, raw, ideal, excessExponent) {
                let norm = raw / stemWidth;
                let exposure = norm / ideal;
                if (exposure > 1) exposure /= (exposure ** excessExponent);
                return exposure;
            }

            function fittedAlpha(blur) { // curve by ChatGPT from empirical tests at 48px font
                return 1 / (1 + 9.035 * (blur / fontSize) ** 2);
            }
        }

        function calculateImageBasedContrast(fgColor, pixelData, heatData) {
            const fgLum = luminance(hexColor(fgColor));
            const HEAT_RED = new Uint8ClampedArray([255, 0, 0, 255]);
            const HEAT_YELLOW = new Uint8ClampedArray([255, 255, 0, 255]);
            const HEAT_GREEN = new Uint8ClampedArray([0, 255, 0, 255]);
            const HEAT_NONE = new Uint8ClampedArray([0, 0, 0, 255]);
            let cBest = 0, cMaskedBest = 0, cWorst = 22, cMaskedWorst = 22; // deliberately out of range
            let rgbBest = [], rgbMaskedBest = [], rgbWorst = [], rgbMaskedWorst = [];
            let boxCount = pixelData.length / 4, inMaskCount = 0;
            let passCount = 0, maskedPassCount = 0; // contrast >= 4.5, WCAG general criterion
            let largeCount = 0, maskedLargeCount = 0; // contrast >= 3, criterion for text >= 18pt
            let lumBoxSum = 0, cBoxSum = 0, lumMaskedSum = 0, cMaskedSum = 0;
            for (let i = 0; i < pixelData.length; i += 4) {
                let inMask = maskBytes[i / 4] === 255;
                
                let rgb = [pixelData[i], pixelData[i + 1], pixelData[i + 2]];
                let bgLum = luminance(rgb);
                let c = contrast(fgLum, bgLum);
                let pass = (c >= 4.5);
                let largePass = (c > 3);

                // Masked outline stats and heatmap
                //
                if (inMask) {
                    ++inMaskCount;
                    lumMaskedSum += bgLum;
                    cMaskedSum += c;
                    if (pass) {
                        ++maskedPassCount;
                        ++maskedLargeCount;
                        heatData.set(HEAT_GREEN, i);
                    } else if (largePass) {
                        ++maskedLargeCount;
                        heatData.set(HEAT_YELLOW, i);
                    } else {
                        heatData.set(HEAT_RED, i);
                    }

                    if (c > cMaskedBest) {
                        cMaskedBest = c;
                        rgbMaskedBest = rgb;
                    }
                    if (c < cMaskedWorst) {
                        cMaskedWorst = c;
                        rgbMaskedWorst = rgb;
                    }
                } else {
                    heatData.set(HEAT_NONE, i);
                }

                // Whole-box stats
                //
                if (pass) ++passCount;
                if (largePass) ++largeCount;
                lumBoxSum += bgLum;
                cBoxSum += c;
                if (c > cMaskedBest) {
                    if (c > cBest) {
                        cBest = c;
                        rgbBest = rgb;
                    }
                }
                if (c < cMaskedWorst) {
                    if (c < cWorst) {
                        cWorst = c;
                        rgbWorst = rgb;
                    }
                }
            }

            $("#image-based pre").innerHTML = [
                "Whole box:",
                `  ${swatch(rgbBest)} best contrast: ${cBest.toFixed(3)}`,
                `  ${swatch(rgbWorst)} worst contrast: ${cWorst.toFixed(3)}`,
                `  WCAG 4.5 pixel pass rate: ${((passCount / boxCount) * 100).toFixed(2)}%`,
                `  WCAG 3.0 pixel pass rate: ${((largeCount / boxCount) * 100).toFixed(2)}%`,
                `  mean luminance: ${(lumBoxSum / boxCount).toFixed(2)}`,
                `  mean contrast: ${(cBoxSum / boxCount).toFixed(2)}`,
                "Outline mask:",
                `  ${swatch(rgbMaskedBest)} best contrast: ${cMaskedBest.toFixed(3)}`,
                `  ${swatch(rgbMaskedWorst)} worst contrast: ${cMaskedWorst.toFixed(3)}`,
                `  WCAG 4.5 pixel pass rate: ${((maskedPassCount / inMaskCount) * 100).toFixed(2)}%`,
                `  WCAG 3.0 pixel pass rate: ${((maskedLargeCount / inMaskCount) * 100).toFixed(2)}%`,
                `  mean luminance: ${(lumMaskedSum / inMaskCount).toFixed(2)}`,
                `  mean contrast: ${(cMaskedSum / inMaskCount).toFixed(2)}`,
                ].join("\n");

            function swatch(rgb) {
                const color = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                return `<span style="background-color:${color}" title="${color}">&nbsp;</span>`;
            }
        }

        /** Extracts all integer values from `s` as an array */
        function numbers(s) {
            return s.match(/[0-9]+/g).map(Number);
        }

        /** Parses `hex` as an `#nnn` hex value, returning [r, g, b] */
        function hexColor(hex) {
            return [parseHexDigit(hex[1]), parseHexDigit(hex[2]), parseHexDigit(hex[3])];
            function parseHexDigit(d) {
                let n = parseInt(d, 16);
                return (n << 4) + n;
            }
        }

        /** Luminance of an `[r, g, b]` uint8-valued array, in the range 0..=1 */
        function luminance(rgb) { // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance
            const [r, g, b] = rgb.map(linearize);
            return (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
            function linearize(c) {
                c /= 255;
                return (c <= 0.04045) 
                    ? (c / 12.92) 
                    : Math.pow(((c + 0.055) / 1.055), 2.4);
            }
        }

        /** Contrast between two luminance values, in the range 1 (worst) to 21 (best) */
        function contrast(lum1, lum2) { // https://www.w3.org/TR/WCAG21/#dfn-contrast-ratio
            const lighter = Math.max(lum1, lum2);
            const darker = Math.min(lum1, lum2);
            return (lighter + 0.05) / (darker + 0.05); // avoid possible divide by zero
        }

        /** Set all select widgets and draw the page */
        function populateFromHashBang() {
            var h = location.hash.replace("#!", "").substr(0, defaultHash.length);
            h += defaultHash.substr(h.length);

            Array.from($$("select")).forEach(validatedSet);
            update();

            function validatedSet(el, i) {
                const v = h[i];
                const legit = Array.from(el.options).map(o => o.value);
                if (legit.includes(v)) {
                    el.value = v;
                } else {
                    let reset = defaultHash[i];
                    alert(`'${v}' is not a valid value for '${el.id}'.\nAllowed values are [${legit}].\nResetting to default '${reset}'.`);
                    el.value = reset;
                }
            }
        }

        /** One-time initialization */
        function init() {
            const checkerboardDataURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAAAAABX3VL4AAAADElEQVQI12Ng+A+EAAYAAf9C8vvWAAAAAElFTkSuQmCC";
            const svg = `
                <svg xmlns="http://www.w3.org/2000/svg" width="300" height="100" viewBox="0 0 300 100" preserveAspectRatio="none">
                <defs>
                    <filter id="dilate" x="-10%" y="-10%" width="120%" height="120%">
                        <feComponentTransfer in="SourceAlpha" result="alpha">
                            <feFuncA type="discrete" tableValues="0 1"/>
                        </feComponentTransfer>
                        <feMorphology in="alpha" operator="dilate" radius="${maskWidth}" result="dilated"/>
                        <feComposite in="dilated" in2="alpha" operator="out" result="border"/>
                        <feFlood flood-color="fuchsia" result="flood"/>
                        <feComposite in="flood" in2="border" operator="in"/>
                    </filter>
                </defs>
                <text x="${pos.x}" y="${pos.y}"
                    dominant-baseline="alphabetic"
                    text-anchor="start"
                    font-family="sans-serif"
                    font-size="${fontSize}px"
                    line-height="1"
                    filter="url(#dilate)"
                    fill="black">${text}</text>
                </svg>`;
            Promise.all([
                imagePromise(checkerboardDataURI),
                imagePromise(URL.createObjectURL(new Blob([svg], { type: "image/svg+xml" })))
            ]).then(([cbImg, svgImg]) => {
                checkerboardImage = cbImg;
                const mctx = maskCanvas.getContext("2d");
                if (isFilterSupported(mctx)) {
                    mctx.drawImage(svgImg, 0, 0);
                    const maskPixels = mctx.getImageData(box.x, box.y, box.w, box.h).data;
                    maskBytes = new Uint8ClampedArray(maskPixels.length / 4);
                    for (let i = 0; i < maskBytes.length; ++i) {
                        maskBytes[i] = maskPixels[i * 4 + 3]; // just take alpha as a boolean equivalent
                    }

                    setUpButton($("button#hide-text"), "hide");
                    setUpButton($("button#show-box"), "box");
                    setUpButton($("button#show-mask"), "mask");
                    setUpButton($("button#show-heat"), "heat");
                    $$("button").forEach(el => el.disabled = false);
                } else {
                    $("#image-based").textContent = "ERROR: CanvasRenderingContext2D.filter not supported, probably because Safari";
                    $("#image-based").style.color = "red";
                }

                window.addEventListener("hashchange", populateFromHashBang);
                document.querySelectorAll("select").forEach(el => el.addEventListener("change", update));
                $$("select").forEach(el => el.disabled = false);
                populateFromHashBang();
            });

            function imagePromise(url) {
                const img = new Image();
                return new Promise((resolve, reject) => {
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = url;
                });
            }

            /** Test for filter support, because Safari lies */
            function isFilterSupported(mctx) {
                mctx.save();
                mctx.fillStyle = "red";
                mctx.filter = "grayscale(100%)";
                mctx.fillRect(0, 0, 2, 2);
                const topLeftPixel = mctx.getImageData(0, 0, 1, 1).data;
                mctx.clearRect(0, 0, 2, 2);
                mctx.restore();
                
                return (topLeftPixel[0] === topLeftPixel[1])
            }

            function setUpButton(el, opt) {
                el.addEventListener("mousedown", e => update(e, opt));
                el.addEventListener("touchstart", e => update(e, opt));
                el.addEventListener("keydown", e => { if (e.code === "Space") update(e, opt); });
                el.addEventListener("mouseup", update);
                el.addEventListener("mouseout", update);
                el.addEventListener("touchend", update);
                el.addEventListener("touchcancel", update);
                el.addEventListener("keyup", e => { if (e.code === "Space") update(); });
            }
        }
    </script>
</body>

</html>